import{_ as l,p as e,q as i,a1 as o}from"./framework-69837a10.js";const t={},n=o("<ul><li><p>pushTarget popTarget</p></li><li><p>callHook怎么触发的生命周期</p></li><li><p>defineReactive做了哪些事情</p></li><li><p>mark 函数</p></li><li><p>measure函数</p></li><li><p>isReserved 函数通过判断一个字符串的第一个字符是不是 $ 或_来决定其是否是保留的</p></li><li><p>_render 做了什么事情</p></li><li><p>setActiveInstance</p></li><li><p>createElm</p></li><li><p>_update 做了什么事情</p><ol><li>设置当前激活的vm const restoreActiveInstance = setActiveInstance(vm)</li><li>第一次执行 vnode 不存在，这个时候会触发 <strong>patch</strong> 挂载 vnode</li><li>prevVnode存在，则传入 prevVnode 和 当前 vNode</li><li>restoreActiveInstance()</li></ol></li><li><p><strong>patch</strong> 做了什么事情</p><ol><li>如果vnode不存在，则当前不需要做dom比对，对当前oldVnode做标记 invokeDestroyHook</li><li>如果 <strong>patch</strong> 传入空，这个时候会</li></ol></li><li><p>mountComponent做了什么事情</p><ol><li>callHook(vm, &#39;beforeMount&#39;)</li><li>设置 updateComponent，该方法中的 _update 会将 $el <strong>patch</strong> 到vm上</li><li>监听component，改变时候派发 callHook(vm, &#39;beforeUpdate&#39;)</li><li>$vode == null时 触发 callHook(vm, &#39;mounted&#39;)</li></ol></li><li><p>$mount</p><ol><li>原先的 $mount，只触发 mountComponent</li><li>重写后的 $mount <ol><li>获取到el</li><li>当前如果不是render模式则需要获取到 template <ol><li>template存在 <ol><li>template是string，看看能不能找到对应的ID，找不到直接提示错误</li><li>如果不是string并且nodeType存在，则template为当前node的innerHTML</li><li>都不存在则报错提升</li></ol></li><li>如果template不存在，但是el存在，则template为el里面的内容</li></ol></li><li>template存在需要对template做一系列处理，compileTodunciton 解析 template</li><li>触发原先的 $mount（相当于触发mountComponent）</li></ol></li></ol></li></ul>",1),p=[n];function a(r,s){return e(),i("div",null,p)}const c=l(t,[["render",a],["__file","question.html.vue"]]);export{c as default};
