import{_ as e,p as i,q as a,a1 as d}from"./framework-69837a10.js";const n={},s=d(`<h2 id="声明式编程和命令式编程" tabindex="-1"><a class="header-anchor" href="#声明式编程和命令式编程" aria-hidden="true">#</a> 声明式编程和命令式编程</h2><p>命令式编程是一种描述计算机所需要做出的行为的编程典范。几乎所有计算机的硬件工作都是命令式的，大部分的编程语言都是命令式的。 声明式编程是一种编程范式。它描述目标的性质，让计算机明白目标，而非流程。</p><blockquote><p>编程范式是编程语言背后的思想,要通过编程语言来体现</p></blockquote><p><code>声明式代码的性能不优于命令式代码的性能</code><code>声明式代码更利于维护，可维护性强</code> 框架设计上要做出关于可维护性和性能上的权衡：对于框架开发者而言，在保持可维护性的同时要让性能损失做到最小</p><h2 id="虚拟dom的性能" tabindex="-1"><a class="header-anchor" href="#虚拟dom的性能" aria-hidden="true">#</a> 虚拟dom的性能</h2><h3 id="创建" tabindex="-1"><a class="header-anchor" href="#创建" aria-hidden="true">#</a> 创建</h3><p>虚拟dom创建页面的过程分为两步：</p><ol><li>创建JavaScript对象，这个对象是基于真实dom的描述；</li><li>递归遍历虚拟DOM树并创建真实DOM。</li></ol><p>虚拟dom创建页面计算量： 创建JavaScript对象（vNode） + 创建所有DOM元素。</p><p>innerHTML创建页面计算量： 渲染HTML字符串 + 新建所有DOM元素</p><h3 id="更新" tabindex="-1"><a class="header-anchor" href="#更新" aria-hidden="true">#</a> 更新</h3><p>innerHTML更新页面过程： 重新构建HTML字符串，重新设置DOM的innerHMTML属性。</p><p>虚拟DOM更新页面过程： 重新创建JavaScript对象（虚拟DOM树），然后对比新旧虚拟DOM，找出变化的元素并更新。</p><p>更新时的性能因素： 虚拟DOM：和数据量的变化有关 innerHTML：和HTML模版大小有关</p><h2 id="运行时和编译时" tabindex="-1"><a class="header-anchor" href="#运行时和编译时" aria-hidden="true">#</a> 运行时和编译时</h2><p>设计框架可选择：</p><ul><li>纯运行时</li><li>纯编译时</li><li>运行时 + 编译时</li></ul><h2 id="框架应该怎么输出构建产物" tabindex="-1"><a class="header-anchor" href="#框架应该怎么输出构建产物" aria-hidden="true">#</a> 框架应该怎么输出构建产物</h2><p>开发环境：需要必要的警告信息（通过tree-shaking处理） 生产环境：不包含警告信息</p><h3 id="场景-希望在html引入后直接使用" tabindex="-1"><a class="header-anchor" href="#场景-希望在html引入后直接使用" aria-hidden="true">#</a> 场景：希望在html引入后直接使用</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&lt;script src=&quot;js/vue.js&quot;&gt;&lt;script/&gt;
&lt;scirpt&gt;
    const { createApp } = vue
&lt;/scirpt&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个时候需要IIFE（立即执行函数），输出的产物则是：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>(function () {
  // ...
}())
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对比rollup.js的配置：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>export default {
  input: &#39;src/main.js&#39;, // 入口文件
  output: {
    file: &#39;bundle.js&#39;, // 输出文件
    format: &#39;cjs&#39; 输出类型 (amd, cjs, es, iife, umd, system)
  }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在主流浏览器对原生ESM支持不错，所以现在用户也能直接引入ESM格式的资源， can I use 可以看到兼容情况, 所以rollup.js 可以输出格式可以配置为: format: es</p>`,26),r=[s];function t(l,c){return i(),a("div",null,r)}const u=e(n,[["render",t],["__file","note.html.vue"]]);export{u as default};
